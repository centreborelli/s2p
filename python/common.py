# Copyright (C) 2015, Carlo de Franchis <carlo.de-franchis@cmla.ens-cachan.fr>
# Copyright (C) 2015, Gabriele Facciolo <facciolo@cmla.ens-cachan.fr>
# Copyright (C) 2015, Enric Meinhardt <enric.meinhardt@cmla.ens-cachan.fr>
# Copyright (C) 2015, Julien Michel <julien.michel@cnes.fr>


import os
import re
import sys
import urllib2
import base64
import urlparse
import datetime
import tempfile
import subprocess
import multiprocessing
import numpy as np


from config import cfg


# add the bin folder to system path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
bin_dir = os.path.join(parent_dir, 'bin')
os.environ['PATH'] = bin_dir + os.pathsep + os.environ['PATH']
os.environ['TMPDIR'] = os.path.join(cfg['temporary_dir'], 'meta/')

# global variable
# list of intermediary files generated by s2p
garbage = list()


def garbage_cleanup():
    """
    Removes all the files listed in the global variable 'garbage'.
    """
    if cfg['clean_tmp']:
        while garbage:
            os.remove(garbage.pop())


def tmpfile(ext=''):
    """
    Creates a temporary file in the cfg['temporary_dir'] directory.

    Args:
        ext: desired file extension. The dot has to be included.

    Returns:
        absolute path to the created file

    The path of the created file is added to the garbage list to allow cleaning
    at the end of the pipeline.
    """
    fd, out = tempfile.mkstemp(suffix=ext, prefix='s2p_',
                               dir=cfg['temporary_dir'])
    os.close(fd)           # http://www.logilab.org/blogentry/17873
    garbage.append(out)
    return out


class RunFailure(Exception):
    pass


def run(cmd, env=os.environ):
    """
    Runs a shell command, and print it before running.

    Arguments:
        cmd: string to be passed to a shell
        env (optional, default value is os.environ): dictionary containing the
            environment variables

    Both stdout and stderr of the shell in which the command is run are those
    of the parent process.
    """
    print("\nRUN: %s" % cmd)
    t = datetime.datetime.now()
    try:
        subprocess.check_call(cmd, shell=True, stdout=sys.stdout,
                              stderr=sys.stdout, env=env)
        print (datetime.datetime.now() - t)

    except subprocess.CalledProcessError as e:
        # raise a custom exception because the CalledProcessError causes the
        # pool to crash
        raise RunFailure({"command": e.cmd, "environment": env, "output":
                          e.output})


def shellquote(s):
    return "'%s'" % s.replace("'", "'\\''")


def matrix_write(filename, m):
    """
    Writes a 3x3 matrix in a txt file using the matlab format.

    Args:
        filename: path of the file where to write the matrix
        m: 3x3 array
    """
    f = open(filename, 'w')
    f.write('[ %.20f  %.20f  %.20f ; ' % (m[0, 0], m[0, 1], m[0, 2]))
    f.write('  %.20f  %.20f  %.20f ; ' % (m[1, 0], m[1, 1], m[1, 2]))
    f.write('  %.20f  %.20f  %.20f ] ' % (m[2, 0], m[2, 1], m[2, 2]))
    f.close()


def matrix_read(filename, size=None):
    """
    Reads a matrix from a txt file assuming the matlab format was used.

    Args:
        filename: path of the file from where to read the matrix
        size: tuple (r, c) telling the number of rows and columns of the matrix

    Returns:
        numpy array
    """
    f = open(filename, 'r')
    m = matrix_read_from_string(f.read(), size)
    f.close()
    return m


def matrix_read_from_string(s, size=None):
    x = s.replace('[', ' ').replace(']', ' ').replace(',', ' ').replace(';', ' ')
    x = map(float, x.split())
    if size:
       return np.array(x).reshape(size[0], size[1])
    else:
       return np.array(x)


def matrix_translation(x, y):
    t = np.eye(3)
    t[0, 2] = x
    t[1, 2] = y
    return t


def image_size(im):
    """
    Reads the width and height of an image.

    Args:
        im: path to the input image file
    Returns:
        a tuple of size 2, giving width and height
    """
    # if tiff, use tiffinfo
    if im.lower().endswith(('.tif', '.tiff')):
        return image_size_tiffinfo(im)

    # else use imprintf (slower)
    try:
        with open(im):
            out = tmpfile('.txt')
            run('imprintf "%%w %%h" %s > %s' % (shellquote(im), out));
            (nc, nr) = map(int, open(out).read().split())
            return (nc, nr)
    except IOError:
        print "image_size: the input file %s doesn't exist" % str(im)
        sys.exit()


def image_size_gdal(im):
    """
    Reads the width and height of an image, using gdal.

    Args:
        im: path to the input image file
    Returns:
        a tuple of size 2, giving width and height
    """
    try:
        with open(im):
            p1 = subprocess.Popen(['gdalinfo', im], stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['grep', 'Size'], stdin=p1.stdout, stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            nc = int(out[2])
            nr = int(out[3])
            return (nc, nr)
    except IOError:
        print "image_size_gdal: the input file %s doesn't exist" % str(im)
        sys.exit()


def image_size_tiffinfo(im):
    """
    Reads the width and height of an image, using tiffinfo.

    Args:
        im: path to the input tif image file
    Returns:
        a tuple of size 2, giving width and height
    """
    if not im.lower().endswith(('.tif', '.tiff')):
        print "image_size_tiffinfo function works only with TIF files"
        print "use image_size_gdal or image_size instead"
        sys.exit()
    try:
        with open(im):
            # redirect stderr to /dev/null on tiffinfo call to discard noisy
            # msg about unknown field with tag 42112
            fnull = open(os.devnull, "w")
            p1 = subprocess.Popen(['tiffinfo', im], stdout=subprocess.PIPE,
                    stderr=fnull)
            p2 = subprocess.Popen(['grep', 'Image Width'], stdin=p1.stdout,
                    stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            nc = int(out[2])
            nr = int(out[5])
            return (nc, nr)
    except IOError:
        print "image_size_tiffinfo: the input file %s doesn't exist" % str(im)
        sys.exit()


def grep_xml(xml_file, tag):
    """
    Reads the value of an element in an xml file.

    Args:
        xml_file: path to the xml file
        tag: start/end tag delimiting the desired element

    Returns:
        A string containing the element written between <tag> and </tag>
        Only the value of the element associated to the first occurence of the
        tag will be returned.
    """
    try:
        with open(xml_file):
            p1 = subprocess.Popen(['grep', tag, xml_file],
                    stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['cut', '-d', '>', '-f', '2'],
                    stdin=p1.stdout, stdout=subprocess.PIPE)
            p3 = subprocess.Popen(['cut', '-d', '<', '-f', '1'],
                    stdin=p2.stdout, stdout=subprocess.PIPE)
            lines = p3.stdout.read().splitlines()
            if not lines:
                print "grep_xml: no tag %s in file %s" % (tag, xml_file)
                return
            if len(lines) > 1:
                print "grep_xml: WARNING several occurences of %s in file %s" % (tag, xml_file)
            return lines[0]
    except IOError:
        print "grep_xml: the input file %s doesn't exist" % xml_file
        sys.exit()



def image_pix_dim(im):
    """
    Reads the number of channels of an image.

    Args:
        im: path to the input image file

    Returns:
        number of channels of the image
    """
    # if tiff, use tiffinfo
    if im.lower().endswith(('.tif', '.tiff')):
        return image_pix_dim_tiffinfo(im)

    # else use imprintf (slower)
    try:
        with open(im):
            out = tmpfile('.txt')
            run('imprintf "%%c" %s > %s' % (shellquote(im), out));
            dim = open(out).readline().split()[0]
            return int(dim)
    except IOError:
        print "image_pix_dim: the input file doesn't exist"
        sys.exit()


def image_pix_dim_tiffinfo(im):
    """
    Reads the number of channels of an image, using tiffinfo

    Args:
        im: path to the input tif image file

    Returns:
        number of channels of the image
    """
    if not im.lower().endswith('.tif'):
        print "image_pix_dim_tiffinfo function works only with TIF files"
        print "use image_pix_dim instead"
        sys.exit()
    try:
        with open(im):
            # redirect stderr to /dev/null on tiffinfo call to discard noisy
            # msg about unknown field with tag 42112
            fnull = open(os.devnull, "w")
            p1 = subprocess.Popen(['tiffinfo', im], stdout=subprocess.PIPE,
                    stderr=fnull)
            p2 = subprocess.Popen(['grep', 'Samples/Pixel'], stdin=p1.stdout,
                    stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            n = int(out[2])
            return n
    except IOError:
        print "image_pix_dim_tiffinfo: file %s doesn't exist" % str(im)
        sys.exit()


def image_crop(im, x, y, w, h, out=None):
    if (out == None):
        out = tmpfile('.tif')
    run('crop %s %s %d %d %d %d' % (im, out, x, y, w, h));
    return out


def image_fftconvolve(im, mtf):
    """
    returns the fourier convolution: F^{-1} ( F(im)  mtf )
    mtf and im must be the same size
    """
    out = tmpfile('.tif')
    run('fftconvolve %s %s %s' % (mtf, im, out))
    return out


def image_zeropadding_from_image_with_target_size(im, image_with_target_size):
    """
    zooms im by zero padding to the size of the image_with_target_size
    It works with the fft representation of im
    and just adds or remove frequencies from it
    No control of Gibbs artifacts
    """
    out = tmpfile('.tif')
    run('zoom_zeropadding %s %s %s' % (image_with_target_size, im, out))
    return out


def image_safe_zoom_fft(im, f, out=None):
    """
    zooms im by a factor: f in [0,1] for zoom in, f in [1 +inf] for zoom out. It
    works with the fft representation of the symmetrized im thus it controls
    the Gibbs artifacts.
    In case of zoom out it filters the image before truncating the
    spectrum, for zoom in it performs a zero padding.
    Because of the discrete frequency representation the zero padding/
    truncation may yield a final zoom factor that differs from the
    desired one, particularly for small source or target images.
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    sz = image_size(im)
    # FFT doesn't play nice with infinite values, so we remove them
    run('zoom_2d %s %s %d %d' % (im, out, sz[0]/f, sz[1]/f))
    return out


def image_zoom_gdal(im, f, out=None, w=None, h=None):
    """
    Zooms an image using gdal (nearest neighbor interpolation)

    Args:
        im: path to the input image
        f:  zoom factor. f in [0,1] for zoom in, f in [1 +inf] for zoom out.
        out (optional): path to the ouput file
        w, h (optional): input image dimensions

    Returns:
        path to the output image. In case f=1, the input image is returned
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    tmp = tmpfile('.tif')

    if w is None or h is None:
        sz = image_size_tiffinfo(im)
        w = sz[0]
        h = sz[1]

    # First, we need to make sure the dataset has a proper origin/spacing
    run('gdal_translate -a_ullr 0 0 %d %d %s %s' % (w/float(f), -h/float(f),
                                                    im, tmp))

    # do the zoom with gdalwarp
    # -wm gives the max memory in MB. If bigger than 2GB, int overflow
    run(('gdalwarp -r near -co "BIGTIFF=IF_NEEDED" -co "TILED=YES" -wm 2047 -ts'
         ' %d %d %s %s') % (w/float(f), h/float(f), tmp, out))
    return out


def cropImage(inp, out, x, y, w, h, zoom=1):
    """
    Crop a rectangular region and apply a zoom.

    Args:
        inp: path to the input file
        out: path to the output file
        x, y, w, h: upper left corner and size of the rectangular region of
            interest
        zoom (default is 1): zoom factor
    """

    if zoom == 1:
        image_crop_tif(inp, x, y, w, h, out)
    else:
        # gdal is used for the zoom because it handles BigTIFF files, and
        # before the zoom out the image may be that big
        tmp = image_crop_tif(inp, x, y, w, h)
        image_zoom_gdal(tmp, zoom, out, w, h)


def image_zoom_out_morpho(im, f):
    """
    Image zoom out by morphological operation (median).

    Args:
        im: path to the input image
        f: zoom out factor. It has to be a positive integer

    Returns:
        path to the output image
    """
    if (f != np.floor(f)):
        print 'image_zoom_out_morpho: zoom factor has to be integer'
        sys.exit()

    out = tmpfile('.tif')
    run('downsa e %d %s %s' % (f, im, out))
    return out


def image_apply_homography(out, im, H, w, h):
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)).

    This function calls the homography binary, rewritten by Marc Lebrun and
    Carlo de Franchis based on a code of Pascal Monasse refactored by Gabriele
    Facciolo.
    """
    # write the matrix to a string
    hij = " ".join(str(x) for x in H.flatten())

    # apply the homography
    run("homography %s -h \"%s\" %s %d %d" % (im, hij, out, w, h))


def median_filter(im, w, n):
    """
    Applies median filter.

    Args:
        im: path to the input image
        w: window size
        n: number of repetitions

    Returns:
        path to the filtered image
    """
    out = tmpfile('.tif')
    run('cp %s %s' % (im, out))
    for i in xrange(n):
        run('morphoop %s median %d %s' % (out, w, out))
    return out


def image_qauto(im, out=None, tilewise=False):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image
        out (optional, default is None): path to output image
        tilewise (optional, default is False): boolean telling wether or not
            use 'tiffu meta'. If True, the output file has to be a *.tif

    Returns:
        path of requantized image, saved as png
    """
    if out is None:
        extension = '.tif' if tilewise else '.png'
        out = tmpfile(extension)
        out = tmpfile(extension)
    if tilewise:
        os.environ['TMPDIR'] = os.path.join(cfg['temporary_dir'], 'meta/')
        run('tiffu meta \"qauto ^ @\" %s -- %s' % (im, out))
    else:
        run('qauto %s %s' % (im, out))
    return out


def image_getminmax(im, out):
    """
    Get min and max intensity

    Args :
        im: path to input image
        out: path to file where min/max values will be stored
    """
    run('getminmax %s %s' % (im, out))


def image_rescaleintensities(im,out,rmin,rmax):
    """
    rescale the values of an input image im, ranging from rmin to rmax,
    to an output image out with values ranging from 0 to 255 (8-bits image)

    Args :
        im: path to input image
        out: path to output image
    """

    run('rescaleintensities %s %s %d %d' % (im, out, rmin, rmax))


def image_qauto_gdal(im):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('gdal_translate -of png -ot Byte -scale %s %s' % (im, out))
    return out


def image_qauto_otb(img_out, img_in, ram=128, gamma=1.5, intensity_cut_high=.1,
                    intensity_cut_low=.1):
    """
    Gamma correction and simplest color balance to 8 bits with otbcli_Convert.

    Args:
        img_out, img_in: paths to output and input images
        ram: allowed memory amount, in MB
        gamma: exponent for the gamma correction applied to the input image
        intensity_cut_high/low: percentage of pixels whose intensity is clipped
            to 255/0.
    """
    gdaltags = ('gdal:co:TILED=YES&'
                'gdal:co:BIGTIFF=IF_SAFER&'
                'gdal:co:PROFILE=BASELINE')
    cmd = ('otbcli_Convert -progress 1 -ram %d'
           ' -type linear'
           ' -type.linear.gamma %f'
           ' -hcp.high %f'
           ' -hcp.low %f'
           ' -in %s'
           ' -out "%s?writegeom=false&%s" uint8') % (ram, gamma,
                                                     intensity_cut_high,
                                                     intensity_cut_low, img_in,
                                                     img_out, gdaltags)
    run(cmd)


def image_qeasy(im, black, white, out=None, tilewise=False):
    """
    Uniform requantization between user-specified min and max levels.

    Args:
        im: path to input image
        black: lower threshold. Values lower or equal are mapped to 0
        white: upper threshold. Values greater or equal are mapped to 255
        out (optional, default is None): path to output image
        tilewise (optional, default is False): boolean telling wether or not
            use 'tiffu meta'

    Returns:
        path of requantized image, saved as png
    """
    if out is None:
        extension = '.tif' if tilewise else '.png'
        out = tmpfile(extension)
        out = tmpfile(extension)
    if tilewise:
        os.environ['TMPDIR'] = os.path.join(cfg['temporary_dir'], 'meta/')
        run('tiffu meta \"qeasy %d %d ^ @\" %s -- %s' % (black, white, im, out))
    else:
        run('qeasy %d %d %s %s' % (black, white, im, out))
    return out


def pansharpened_to_panchro(im, out=None, tilewise=False):
    """
    Converts a RGBI pansharpened image to a graylevel image.

    Args:
        im: path to the input image
        out (optional): path to the output image
        tilewise (optional, default is False): boolean telling wether or not
            use 'tiffu meta'

    Returns:
        path to the output image
    """
    if out is None:
        out = tmpfile('.tif')
    pcmd = "x[0] x[1] x[2] x[3] + + + 4 /"

    if tilewise:
        os.environ['TMPDIR'] = os.path.join(cfg['temporary_dir'], 'meta/')
        cmd = 'tiffu meta \"plambda ^ \\\"%s\\\" -o @\" %s -- %s' % (pcmd, im,
                                                                     out)
    else:
        cmd = 'plambda %s \"%s\" -o %s' % (im, pcmd, out)

    run(cmd)
    return out


def rgbi_to_rgb(im, out=None, tilewise=False):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, with iio

    Args:
        im: path to the input image
        out (optional): path to the output image
        tilewise (optional, default is False): boolean telling wether or not
            use 'tiffu meta'

    Returns:
        output rgb image
    """
    if out is None:
        extension = '.tif' if tilewise else '.png'
        out = tmpfile(extension)
        out = tmpfile(extension)
    pcmd = "x[0] x[1] 0.9 * x[3] 0.1 * + x[2] join3"

    if tilewise:
        os.environ['TMPDIR'] = os.path.join(cfg['temporary_dir'], 'meta/')
        cmd = 'tiffu meta \"plambda ^ \\\"%s\\\" -o @\" %s -- %s' % (pcmd, im,
                                                                     out)
    else:
        cmd = 'plambda %s \"%s\" -o %s' % (im, pcmd, out)

    run(cmd)
    return out


def rgbi_to_rgb_gdal(im):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, using gdal

    Args:
        im: path to the input image

    Returns:
        output rgb image
    """
    out = tmpfile('.tif')
    run('gdal_translate -b 1 -b 2 -b 3 %s %s' %(im, out))
    return out


def points_apply_homography(H, pts):
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    # if the list of points is not a numpy array, convert it
    if (type(pts) == list):
        pts = np.array(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        print """points_apply_homography: ERROR the input must be a numpy array
          of 2D points, one point per line"""
        return
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts = (np.dot(H, pts.T)).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts):
    """
    bounding box for the points pts
    """
    dim = len(pts[0])  # should be 2
    bb_min = [min([t[i] for t in pts]) for i in xrange(dim)]
    bb_max = [max([t[i] for t in pts]) for i in xrange(dim)]
    return bb_min[0], bb_min[1], bb_max[0] - bb_min[0], bb_max[1] - bb_min[1]


def image_crop_tif(im, x, y, w, h, out=None):
    """
    Crops tif images.

    Args:
        im: path to a tif image, or to a tile map file (*.til)
        x, y, w, h: four integers definig the rectangular crop in the image.
            (x, y) is the top-left corner, and (w, h) are the dimensions of the
            rectangle.
        out (optional): path to the output crop

    Returns:
        path to cropped tif image

    The crop is made with the gdal_translate binary, from gdal library. We
    tried to use tiffcrop but it fails.
    """
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_tif will round the coordinates of your crop'

    if out is None:
        out = tmpfile('.tif')

    try:
        with open(im, 'r'):
            # do the crop with gdal_translate
            run(('gdal_translate -ot Float32 -co TILED=YES -co BIGTIFF=IF_NEEDED '
                 '-srcwin %d %d %d %d %s %s') % (x, y, w, h, shellquote(im),
                                                 shellquote(out)))

    except IOError:
        print """image_crop_tif: input image %s not found! Verify your paths to
                 Pleiades full images"""%shellquote(im)
        sys.exit()

    return out


def image_crop_LARGE(im, x, y, w, h):
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_LARGE will round the coordinates of your crop'
    if im.lower().endswith(('tif', 'tiff', 'til')):
       return image_crop_tif(im, x, y, w, h)
    else:
       print "image_crop_LARGE: the input image must be tif, tiff or til"
       return image_crop(im, x, y, w, h)


def image_pleiades_unsharpening_mtf():
    """
    Returns the filename (with path) of a precomputed unsharpening MTF fror
    sensor perfect pleiades images.

    This filter has been pre-computed for processing sensor perfect images
    resampled with a factor 1.4x. But in theory it should be adapted depending
    on the RESAMPLING_SPACING stored in the RPC xml files.
    """
    s2p_dir = os.path.dirname(os.path.dirname(os.path.realpath(os.path.abspath(__file__))))
    return os.path.join(s2p_dir, 'data', 'idata_0009_MTF_89x89.tif')


def run_binary_on_list_of_points(points, binary, option=None, env_var=None):
    """
    Runs a binary that reads its input on stdin.

    Args:
        points: numpy array containing all the input points, one per line
        binary: path to the binary. It is supposed to write one output value on
            stdout for each input point
        option: optional option to pass to the binary
        env_var (optional): environment variable that modifies the behaviour of
            the binary. It is a tuple containing 2 strings, eg ('PATH', '/bin')

    Returns:
        a numpy array containing all the output points, one per line.
    """
    # send the input points to stdin
    pts_file = tmpfile('.txt')
    np.savetxt(pts_file, points, '%.18f')
    p1 = subprocess.Popen(['cat', pts_file], stdout=subprocess.PIPE)

    # run the binary
    env = os.environ.copy()
    if env_var is not None:
        env[env_var[0]] = env_var[1]
    cmd = [binary]
    if option is not None:
        cmd.append(option)
    p2 = subprocess.Popen(cmd, env=env, stdin=p1.stdout,
                          stdout=subprocess.PIPE)

    # recover output values
    out = []
    for i in xrange(len(points)):
        out.append([float(x) for x in p2.stdout.readline().split()])

    return np.array(out)


def get_rectangle_coordinates(im):
    """
    Get the coordinates of a rectangle defined by the user's clicks.

    Args:
        im: path to an image to be displayed.

    Returns:
        x, y, w, h: coordinates of the rectangle selected by the user. x, y are the
            coordinates of the top-left corner, while (w, h) is the size of the
            rectangle.
    """
    points_file = tmpfile('.txt')
    current_dir = os.path.dirname(os.path.abspath(__file__))
    run('python viewGL.py %s > %s' % (shellquote(im), points_file))
    (x1, y1, x2, y2) = map(int, open(points_file).read().split())
    # viewGL.py returns the coordinates of two corners defining the rectangle.
    # We can's make any assumption on the ordering of these coordinates.

    x = min(x1, x2)
    w = max(x1, x2) - x
    y = min(y1, y2)
    h = max(y1, y2) - y
    return x, y, w, h


def get_roi_coordinates(img, preview):
    """
    Get the coordinates of a desired ROI in a Pleiades image from user's clicks.

    Args:
        img: path to the full image file
        preview: path to the preview image file

    Returns:
        x, y, w, h: coordinates of the ROI selected by the user, in the
            full image frame. x, y are the coordinates of the top-left corner,
            while (w, h) is the size of the rectangle.

    A preview image is displayed, on which the user selects a rectangular
    region.
    """

    # read preview/full images dimensions
    nc, nr = image_size_gdal(img)
    nc_preview, nr_preview = image_size_gdal(preview)

    # get the rectangle coordinates
    x, y, w, h = get_rectangle_coordinates(preview)

    # rescale according to preview/full ratio
    x = int(x*nc/nc_preview)
    y = int(y*nr/nr_preview)
    w = int(w*nc/nc_preview)
    h = int(h*nr/nr_preview)
    return x, y, w, h


def is_image_black(img):
    """
    Returns True if all the pixels of the image are 0.
    """
    try:
        with open(img):
            p = subprocess.Popen(['imprintf', '%e\n', img], stdout=subprocess.PIPE)
            out = p.stdout.readline()
            return (out == '0\n')
    except IOError:
        print "is_image_black: the input file %s doesn't exist" % str(img)
        sys.exit()


def is_exe(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """
    Test if a program exists, and returns its path.

    Args:
        program: name of the binary, or its full path. For example, "ls", or
            "/bin/ls".

    Returns:
        full path to the binary if it exists, None if it doesn't.

    This function was copied from:
    http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
    """
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


def url_with_authorization_header(from_url):
    """
    Add authorization header

    Args:
        from_url: url of the file to download
    """
    scheme, netloc, path, param, query = urlparse.urlsplit(from_url)
    if "@" in netloc:
        userinfo = netloc.rsplit("@",1)[0]
        if ":" in userinfo:
            username = userinfo.rsplit(":",1)[0]
            password = userinfo.rsplit(":",1)[1]
            netloc = netloc.rsplit("@",1)[1]

            from_url = urlparse.urlunsplit((scheme, netloc, path, param, query))

            if username != None and password != None:
                request = urllib2.Request(from_url)
                base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
                request.add_header("Authorization", "Basic %s" % base64string)
                from_url = request

    return from_url


def download(to_file, from_url):
    """
    Download a file from the internet.

    Args:
        to_file: path where to store the downloaded file
        from_url: url of the file to download
    """
    f = open(to_file, 'wb')
    file_size_dl = 0
    block_sz = 8192

    try:
        u = urllib2.urlopen(from_url)
        meta = u.info()
        file_size = int(meta.getheaders("Content-Length")[0])
        print "Downloading: %s Bytes: %s" % (to_file, file_size)

        while True:
            buffer = u.read(block_sz)
            if not buffer:
                break

            file_size_dl += len(buffer)
            f.write(buffer)
            status = r"%10d  [%3.2f%%]" % (file_size_dl, file_size_dl * 100. / file_size)
            status = status + chr(8)*(len(status)+1)
            print status,

    except urllib2.URLError as e:
        print "Download failed: ", e

    f.close()


def round_roi_to_nearest_multiple(n, x, y, w, h):
    """
    Rounds coordinates of a ROI to the nearest multiple of a given int.

    Args:
        n: integer
        x, y, w, h: 4 numbers defining a ROI

    Returns:
        x, y, w, h: 4 ints close to the input numbers. x and y are rounded
            down, while w and h are rounded up to the nearest multiple of n.
    """
    x, y, w, h = map(float, [x, y, w, h])
    x = n * np.floor(x / n)
    y = n * np.floor(y / n)
    w = n * np.ceil(w / n)
    h = n * np.ceil(h / n)
    return map(int, [x, y, w, h])


def lidar_preprocessor(output, input_plys):
    """
    Compute a multi-scale representation of a large point cloud.

    The output file can be viewed with LidarPreprocessor. This is useful for
    huge point clouds. The input is a list of ply files.

    Args:
        output: path to the output folder
        input_plys: list of paths to ply files
    """
    tmp = cfg['temporary_dir']
    nthreads = multiprocessing.cpu_count()
    plys = ' '.join(input_plys)
    common.run("LidarPreprocessor -to %s/LidarO -tp %s/LidarP -nt %d %s -o %s" % (
        tmp, tmp, nthreads, plys, output))
