# Copyright (C) 2013, Carlo de Franchis <carlodef@gmail.com>
# Copyright (C) 2013, Gabriele Facciolo <gfacciol@gmail.com>

# This Python file uses the following encoding: utf-8
import numpy as np
import os
import sys
import subprocess
import tempfile
import re

import rpc_model
from config import cfg


# add the bin folder to system path
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
bin_dir = os.path.join(parent_dir, 'bin')
os.environ['PATH'] = bin_dir + os.pathsep + os.environ['PATH']

# global variable
# list of intermediary files generated by the script
garbage = list()

def garbage_cleanup():
    """
    Removes all the files listed in the global variable 'garbage'.
    """
    if cfg['clean_tmp']:
        while garbage:
            run('rm %s' % garbage.pop())


def tmpfile(ext=''):
    """
    Creates a temporary file in the /tmp directory.

    Args:
        ext: desired file extension

    Returns:
        absolute path to the created file

    The path of the created file is added to the garbage list to allow cleaning
    at the end of the pipeline.
    """
    fd, out = tempfile.mkstemp(suffix = ext, prefix = 's2p_', dir = cfg['temporary_dir'])
    garbage.append(out)
    os.close(fd)           # http://www.logilab.org/blogentry/17873
    return out


def run(cmd):
    """
    Runs a shell command, and print it before running.

    Arguments:
        cmd: string to be passed to a shell

    Both stdout and stderr of the shell in which the command is run are those
    of the parent process.
    """
    print cmd
    subprocess.call(cmd, shell=True, stdout=sys.stdout, stderr=subprocess.STDOUT,
        env=os.environ)
    return


def shellquote(s):
    return "'" + s.replace("'", "'\\''") + "'"


def matrix_write(filename, H):
    """
    Writes a 3x3 matrix in a file using the matlab format.

    Args:
        filename: path of the file where to write the matrix
        H: 3x3 array
    """
    f = open(filename, 'w')
    f.write('[ %.20f  %.20f  %.20f ; ' % (H[0, 0], H[0, 1], H[0, 2]))
    f.write('  %.20f  %.20f  %.20f ; ' % (H[1, 0], H[1, 1], H[1, 2]))
    f.write('  %.20f  %.20f  %.20f ] ' % (H[2, 0], H[2, 1], H[2, 2]))
    f.close()


def matrix_read(fileName, rows=None, cols=None):
    return matrix_read_from_string(open(fileName).read(), rows, cols)


def matrix_read_from_string(line, rows=None, cols=None):
    x0 = []
    line = line.replace('[',' ')
    line = line.replace(']',' ')
    line = line.replace(',',' ')
    line = line.replace(';',' ')
    da = line.split()
    x0.append(map(float,da))
    #
    if(cols == None):
       x0 = np.array(x0)
    else:
       x0 = np.array(x0).reshape(rows, cols)
    #
    return(x0)


def matrix_translation(tx, ty):
    T = np.eye(3)
    T[0, 2] = tx;
    T[1, 2] = ty;
    return T


def image_size(im):
    """
    Reads the width and height of an image.

    Args:
        im: path to the input image file
    Returns:
        a tuple of size 2, giving width and height
    """
    try:
        with open(im):
            out = tmpfile('.txt')
            run('imprintf "%%w %%h" %s > %s' % (shellquote(im), out));
            (nc, nr) = map(int, open(out).read().split())
            return (nc, nr)
    except IOError:
        print "image_size: the input file %s doesn't exist" % str(im)
        sys.exit()


def image_size_gdal(im):
    """
    Reads the width and height of an image, using gdal.

    Args:
        im: path to the input image file
    Returns:
        a tuple of size 2, giving width and height
    """
    try:
        with open(im):
            p1 = subprocess.Popen(['gdalinfo', im], stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['grep', 'Size'], stdin=p1.stdout, stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            nc = int(out[2])
            nr = int(out[3])
            return (nc, nr)
    except IOError:
        print "image_size_gdal: the input file %s doesn't exist" % str(im)
        sys.exit()


def image_size_tiffinfo(im):
    """
    Reads the width and height of an image, using tiffinfo.

    Args:
        im: path to the input tif image file
    Returns:
        a tuple of size 2, giving width and height
    """
    if not im.lower().endswith('.tif'):
        print "image_size_tiffinfo function works only with TIF files"
        print "use image_size_gdal or image_size instead"
        sys.exit()
    try:
        with open(im):
            # redirect stderr to /dev/null on tiffinfo call to discard noisy
            # msg about unknown field with tag 42112
            fnull = open(os.devnull, "w")
            p1 = subprocess.Popen(['tiffinfo', im], stdout=subprocess.PIPE,
                    stderr=fnull)
            p2 = subprocess.Popen(['grep', 'Image Width'], stdin=p1.stdout,
                    stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            nc = int(out[2])
            nr = int(out[5])
            return (nc, nr)
    except IOError:
        print "image_size_tiffinfo: the input file %s doesn't exist" % str(im)
        sys.exit()


def grep_xml(xml_file, tag):
    """
    Reads the value of an element in an xml file.

    Args:
        xml_file: path to the xml file
        tag: start/end tag delimiting the desired element

    Returns:
        A string containing the element written between <tag> and </tag>
        Only the value of the element associated to the first occurence of the
        tag will be returned.
    """
    try:
        with open(xml_file):
            p1 = subprocess.Popen(['grep', tag, xml_file],
                    stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['cut', '-d', '>', '-f', '2'],
                    stdin=p1.stdout, stdout=subprocess.PIPE)
            p3 = subprocess.Popen(['cut', '-d', '<', '-f', '1'],
                    stdin=p2.stdout, stdout=subprocess.PIPE)
            lines = p3.stdout.read().splitlines()
            if not lines:
                print "grep_xml: no tag %s in file %s" % (tag, xml_file)
                return
            if len(lines) > 1:
                print "grep_xml: WARNING several occurences of %s in file %s" % (tag, xml_file)
            return lines[0]
    except IOError:
        print "grep_xml: the input file %s doesn't exist" % xml_file
        sys.exit()



def image_pix_dim(im):
    """
    Reads the number of channels of an image.

    Args:
        im: path to the input image file

    Returns:
        number of channels of the image
    """
    try:
        with open(im):
            out = tmpfile('.txt')
            run('imprintf "%%c" %s > %s' % (shellquote(im), out));
            dim = open(out).readline().split()[0]
            return int(dim)
    except IOError:
        print "image_pix_dim: the input file doesn't exist"
        sys.exit()


def image_pix_dim_tiffinfo(im):
    """
    Reads the number of channels of an image, using tiffinfo

    Args:
        im: path to the input tif image file

    Returns:
        number of channels of the image
    """
    if not im.lower().endswith('.tif'):
        print "image_pix_dim_tiffinfo function works only with TIF files"
        print "use image_pix_dim instead"
        sys.exit()
    try:
        with open(im):
            # redirect stderr to /dev/null on tiffinfo call to discard noisy
            # msg about unknown field with tag 42112
            fnull = open(os.devnull, "w")
            p1 = subprocess.Popen(['tiffinfo', im], stdout=subprocess.PIPE,
                    stderr=fnull)
            p2 = subprocess.Popen(['grep', 'Samples/Pixel'], stdin=p1.stdout,
                    stdout=subprocess.PIPE)
            line = p2.stdout.readline()
            out = re.findall(r"[\w']+", line)
            n = int(out[2])
            return n
    except IOError:
        print "image_pix_dim_tiffinfo: file %s doesn't exist" % str(im)
        sys.exit()

def image_crop(im, x, y, w, h, out=None):
    if (out == None):
        out = tmpfile('.tif')
    run('crop %s %s %d %d %d %d' % (im, out, x, y, w, h));
    return out


def image_fftconvolve(im, mtf):
    """
    returns the fourier convolution: F^{-1} ( F(im)  mtf )
    mtf and im must be the same size
    """
    out = tmpfile('.tif')
    run('fftconvolve %s %s %s' % (mtf, im, out))
    return out


def image_zeropadding_from_image_with_target_size(im, image_with_target_size):
    """
    zooms im by zero padding to the size of the image_with_target_size
    It works with the fft representation of im
    and just adds or remove frequencies from it
    No control of Gibbs artifacts
    """
    out = tmpfile('.tif')
    run('zoom_zeropadding %s %s %s' % (image_with_target_size, im, out))
    return out

def image_safe_zoom_fft(im, f, out=None):
    """
    zooms im by a factor: f in [0,1] for zoom in, f in [1 +inf] for zoom out. It
    works with the fft representation of the symmetrized im thus it controls
    the Gibbs artifacts.
    In case of zoom out it filters the image before truncating the
    spectrum, for zoom in it performs a zero padding.
    Because of the discrete frequency representation the zero padding/
    truncation may yield a final zoom factor that differs from the
    desired one, particularly for small source or target images.
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    sz = image_size(im)
    # FFT doesn't play nice with infinite values, so we remove them
    run('zoom_2d %s %s %d %d' % (im, out, sz[0]/f, sz[1]/f))
    return out

def image_zoom_gdal(im, f, out=None, w=None, h=None):
    """
    Zooms an image using gdal (cubic interpolation)

    Args:
        im: path to the input image
        f:  zoom factor. f in [0,1] for zoom in, f in [1 +inf] for zoom out.
        out (optional): path to the ouput file
        w, h (optional): input image dimensions

    Returns:
        path to the output image. In case f=1, the input image is returned
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    tmp = tmpfile('.tif')

    if w is None or h is None:
        sz = image_size_tiffinfo(im)
        w = sz[0]
        h = sz[1]

    # First, we need to make sure the dataset has a proper origin/spacing
    run('gdal_translate -a_ullr 0 0 %d %d %s %s' % (w/float(f), -h/float(f), im, tmp))

    # do the zoom with gdalwarp
    run('gdalwarp -r cubic -ts %d %d %s %s' %  (w/float(f), h/float(f), tmp, out))
    return out


def image_zoom_out_morpho(im, f):
    """
    Image zoom out by morphological operation (median).

    Args:
        im: path to the input image
        f: zoom out factor. It has to be a positive integer

    Returns:
        path to the output image
    """
    if (f != np.floor(f)):
        print 'image_zoom_out_morpho: zoom factor has to be integer'
        sys.exit()

    out = tmpfile('.tif')
    run('downsa e %d %s %s' % (f, im, out))
    return out


def image_apply_homography(out, im, H, w, h):
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)). This function calls
    Pascal Monasse homography binary, refactored by Gabriele.
    """
    # write the matrix to a file
    Hf = tmpfile('.txt')
    matrix_write(Hf, H)
    # apply the homography
    out_png = tmpfile('.png')
    run("homography %s %s %s %s 0 %d %d" % (im, Hf, out_png, out, w, h))
    return


def median_filter(im, w, n):
    """
    Applies median filter.

    Args:
        im: path to the input image
        w: window size
        n: number of repetitions

    Returns:
        path to the filtered image
    """
    out = tmpfile('.tif')
    run('cp %s %s' % (im, out))
    for i in xrange(n):
        run('morphoop %s median %d %s' % (out, w, out))
    return out



def image_qauto(im):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('qauto %s %s' % (im, out))
    return out


def image_qauto_gdal(im):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('gdal_translate -of png -co profile=baseline -ot Byte -scale %s %s' % (im, out))
    return out


def image_qeasy(im, black, white):
    """
    Uniform requantization between user-specified min and max levels.

    Args:
        im: path to input image
        black: lower threshold. Values lower or equal are mapped to 0
        white: upper threshold. Values greater or equal are mapped to 255

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('gdal_translate -of png -co profile=baseline -ot Byte -scale %d %d %s %s' % (black, white, im, out))
    return out


def pansharpened_to_panchro(im, out=None):
    """
    Converts a RGBI pansharpened image to a graylevel image.

    Args:
        im: path to the input image
        out (optional): path to the output image

    Returns:
        path to the output image
    """
    if out is None:
        out = tmpfile('.tif')
    run('plambda %s "x[0] x[1] x[2] x[3] + + + 4 /" -o %s' % (im, out))
    return out



def rgbi_to_rgb(im):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, with iio

    Args:
        im: path to the input image

    Returns:
        output rgb image
    """
    out = tmpfile('.tif')
    run('plambda %s "x[0] x[1] 0.9 * x[3] 0.1 * + x[2] join3" -o %s'%(im, out))
    return out


def rgbi_to_rgb_gdal(im):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, using gdal

    Args:
        im: path to the input image

    Returns:
        output rgb image
    """
    out = tmpfile('.tif')
    run('gdal_translate -co profile=baseline -b 1 -b 2 -b 3 %s %s' %(im, out))
    return out


def image_sift_keypoints(im, keyfile=None, max_nb=None,
        implementation='monasse', extra_params=''):
    """
    Runs sift (the keypoints detection and description only, no matching).

    Args:
        im: path to the input image
        keyfile (optional): path to the file where to write the list of sift
            descriptors
        max_nb (optional): maximal number of keypoints. If more keypoints are
            detected, those at smallest scales are discarded
        implementation (optional, default is 'monasse'): option to choose which
            implementation of SIFT to use. Two options are supported: 'ipol'
            and 'monasse'
        extra_params (optional, default is ''): extra parameters to be passed
            to the 'ipol' implementation

    Returns:
        path to the file containing the list of descriptors
    """
    if keyfile is None:
       keyfile = tmpfile('.txt')

    if implementation is 'monasse':
        run("sift_keypoints %s %s" % (image_qauto(im), keyfile))

        # remove the first line (header) from keypoint files
        tmp = tmpfile('.txt')
        run("tail -n +2 %s > %s" % (keyfile, tmp))
        run("cp %s %s" % (tmp, keyfile))

    elif implementation is 'ipol':
        # the awk call is used to swap the first two columns of the output
        # to print the keypoint coordinates in that order: x, y
        run("sift_cli %s %s|awk '{ t = $1; $1 = $2; $2 = t; print; }' > %s" % (
            image_qauto(im), extra_params, keyfile))

    else:
        print "ERROR: image_sift_keypoints bad 'implementation' argument"

    # keep only the first max_nb points
    if max_nb is not None:
        run("head -n %d %s > %s" % (max_nb, keyfile, tmp))
        run("cp %s %s" % (tmp, keyfile))
    return keyfile


def sift_keypoints_match(k1, k2, method='relative', thresh=0.6):
    """
    Find matches among two lists of sift keypoints.

    Args:
        k1, k2: paths to text files containing the lists of sift descriptors
        method (optional, default is 'relative'): flag ('relative' or
            'absolute') indicating wether to use absolute distance or relative
            distance
        thresh (optional, default is 0.6): threshold for distance between SIFT
            descriptors. These descriptors are 128-vectors, whose coefficients
            range from 0 to 255, thus with absolute distance a reasonable value
            for this threshold is between 200 and 300. With relative distance
            (ie ratio between distance to nearest and distance to second
            nearest), the commonly used value for the threshold is 0.6.

    Returns:
        a numpy 2D array containing the list of matches

    It uses Ives' matching binary, from the IPOL http://www.ipol.im/pub/pre/82/
    """
    matchfile = tmpfile('.txt')
    run("match_cli %s %s -%s %f > %s" % (k1, k2, method, thresh, matchfile))
    matches = np.loadtxt(matchfile)
    if matches.size == 0:
        # no matches
        return np.array([[]])
    if len(matches.shape) == 1:
        # only one match
        # discard scale and orientation, then return
        return matches[[0, 1, 4, 5]].reshape(1, 4)

    # last case, 'matches' is already a 2D array
    return matches[:, [0, 1, 4, 5]]


def points_apply_homography(H, pts):
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    # if the list of points is not a numpy array, convert it
    if (type(pts) == list):
        pts = np.array(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        print """points_apply_homography: ERROR the input must be a numpy array
          of 2D points, one point per line"""
        return
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts = (np.dot(H, pts.T)).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts):
    """
    bounding box for the points pts
    """
    dim = len(pts[0])      #should be 2
    bb_min = [ min([ t[i] for t in pts ]) for i in range(0, dim) ]
    bb_max = [ max([ t[i] for t in pts ]) for i in range(0, dim) ]
    x, y, w, h = bb_min[0], bb_min[1], bb_max[0]-bb_min[0], bb_max[1]-bb_min[1]
    return x, y, w, h


def image_crop_TIFF(im, x, y, w, h, out=None):
    """
    Crops tif images.

    Args:
        im: path to a tif image, or to a tile map file (*.til)
        x, y, w, h: four integers definig the rectangular crop in the image.
            (x, y) is the top-left corner, and (w, h) are the dimensions of the
            rectangle.
        out (optional): path to the output crop

    Returns:
        path to cropped tif image

    The crop is made with the gdal_translate binary, from gdal library. We
    tried to use tiffcrop but it fails.
    """
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_TIFF will round the coordinates of your crop'

    if out is None:
        out = tmpfile('.tif')

    try:
        with open(im, 'r'):
            # do the crop with gdal_translate, with option to remove any GDAL or GeoTIFF tag
            run('gdal_translate -co profile=baseline -srcwin %d %d %d %d %s %s' % (x,
                y, w, h, shellquote(im), shellquote(out)))

    except IOError:
        print """image_crop_TIFF: input image not found! Verify your paths to
                 Pleiades full images"""
        sys.exit()

    return out


def image_crop_LARGE(im, x, y, w, h):
    if (int(x) != x or int(y) != y):
        print 'Warning: image_crop_LARGE will round the coordinates of your crop'
    if im.lower().endswith(('tif', 'tiff', 'til')):
       return image_crop_TIFF(im, x, y, w, h)
    else:
       print "image_crop_LARGE: the input image must be tif, tiff or til"
       return image_crop(im, x, y, w, h)


def image_pleiades_unsharpening_mtf():
    """
    Returns the filename (with path) of a precomputed unsharpening MTF fror
    sensor perfect pleiades images.

    This filter has been pre-computed for processing sensor perfect images
    resampled with a factor 1.4x. But in theory it should be adapted depending
    on the RESAMPLING_SPACING stored in the RPC xml files.
    """
    return '%s/idata_0009_MTF_89x89.tif'%(os.path.dirname(
                                                os.path.abspath(__file__)))


def run_binary_on_list_of_points(points, binary, option=None):
    """
    Runs a binary that reads its input on stdin.

    Args:
        points: numpy array containing all the input points, one per line
        binary: path to the binary. It is supposed to write one output value on
            stdout for each input point
        option: optional option to pass to the binary

    Returns:
        a numpy array containing all the output points, one per line.
    """
    # run the binary
    pts_file = tmpfile('.txt')
    np.savetxt(pts_file, points, '%.18f')
    p1 = subprocess.Popen(['cat', pts_file], stdout = subprocess.PIPE)
    if option:
        p2 = subprocess.Popen([binary, option], stdin = p1.stdout, stdout =
            subprocess.PIPE)
    else:
        p2 = subprocess.Popen([binary], stdin = p1.stdout, stdout =
            subprocess.PIPE)

    # recover output values: first point first, then loop over all the others
    line = p2.stdout.readline()
    out = np.array([[float(val) for val in line.split()]])
    for i in range(1, len(points)):
        line = p2.stdout.readline()
        l = [float(val) for val in line.split()]
        out = np.vstack((out, l))

    return out


def get_rectangle_coordinates(im):
    """
    Get the coordinates of a rectangle defined by the user's clicks.

    Args:
        im: path to an image to be displayed.

    Returns:
        x, y, w, h: coordinates of the rectangle selected by the user. x, y are the
            coordinates of the top-left corner, while (w, h) is the size of the
            rectangle.
    """
    points_file = tmpfile('.txt')
    current_dir = os.path.dirname(os.path.abspath(__file__))
    run('%s/viewGL.py %s > %s' % (current_dir, shellquote(im), points_file));
    (x1, y1, x2, y2) = map(int, open(points_file).read().split())
    # viewGL.py returns the coordinates of two corners defining the rectangle.
    # We can's make any assumption on the ordering of these coordinates.

    x = min(x1, x2)
    w = max(x1, x2) - x
    y = min(y1, y2)
    h = max(y1, y2) - y
    return x, y, w, h


def get_roi_coordinates(img, preview):
    """
    Get the coordinates of a desired ROI in a Pleiades image from user's clicks.

    Args:
        img: path to the full image file
        preview: path to the preview image file

    Returns:
        x, y, w, h: coordinates of the ROI selected by the user, in the
            full image frame. x, y are the coordinates of the top-left corner,
            while (w, h) is the size of the rectangle.

    A preview image is displayed, on which the user selects a rectangular
    region.
    """

    # read preview/full images dimensions
    nc, nr = image_size_gdal(img)
    nc_preview, nr_preview = image_size_gdal(preview)

    # get the rectangle coordinates
    x, y, w, h = get_rectangle_coordinates(preview)

    # rescale according to preview/full ratio
    x = int(x*nc/nc_preview)
    y = int(y*nr/nr_preview)
    w = int(w*nc/nc_preview)
    h = int(h*nr/nr_preview)
    return x, y, w, h


def is_image_black(img):
    """
    Returns True if all the pixels of the image are 0.
    """
    try:
        with open(img):
            p = subprocess.Popen(['imprintf', '%e\n', img], stdout=subprocess.PIPE)
            out = p.stdout.readline()
            return (out == '0\n')
    except IOError:
        print "is_image_black: the input file %s doesn't exist" % str(im)
        sys.exit()


def is_exe(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """
    Test if a program exists, and returns its path.

    Args:
        program: name of the binary, or its full path. For example, "ls", or
            "/bin/ls".

    Returns:
        full path to the binary if it exists, None if it doesn't.

    This function was copied from:
    http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
    """

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None
