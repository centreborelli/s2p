# Copyright (C) 2015, Carlo de Franchis <carlo.de-franchis@cmla.ens-cachan.fr>
# Copyright (C) 2015, Gabriele Facciolo <facciolo@cmla.ens-cachan.fr>
# Copyright (C) 2015, Enric Meinhardt <enric.meinhardt@cmla.ens-cachan.fr>
# Copyright (C) 2015, Julien Michel <julien.michel@cnes.fr>


import os
import sys
import datetime
from typing import Any, Dict, List, Tuple, Union, Optional
import warnings
import tempfile
import subprocess
import numpy as np
import numpy.typing as npt
import rasterio
import rasterio.errors


from s2p.config import cfg


# silent rasterio NotGeoreferencedWarning
warnings.filterwarnings("ignore",
                        category=rasterio.errors.NotGeoreferencedWarning)

# add the bin folder to system path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
bin_dir = os.path.join(parent_dir, 'bin')
os.environ['PATH'] = bin_dir + os.pathsep + os.environ['PATH']

# global variable
# list of intermediary files generated by s2p
garbage: List[str] = list()


def remove(target: str) -> None:
    try:
        os.remove(target)
    except OSError:
        pass

def garbage_cleanup() -> None:
    """
    Removes all the files listed in the global variable 'garbage'.
    """
    if cfg['clean_tmp']:
        while garbage:
            remove(garbage.pop())


def tmpfile(ext: str = '') -> str:
    """
    Creates a temporary file in the cfg['temporary_dir'] directory.

    Args:
        ext: desired file extension. The dot has to be included.

    Returns:
        absolute path to the created file

    The path of the created file is added to the garbage list to allow cleaning
    at the end of the pipeline.
    """
    fd, out = tempfile.mkstemp(suffix=ext, prefix='s2p_',
                               dir=os.path.expandvars(cfg['temporary_dir']))
    os.close(fd)           # http://www.logilab.org/blogentry/17873
    garbage.append(out)
    return out


def run(cmd: Union[str, List[str]],
        env=os.environ,
        timeout: Optional[bool] = None,
        shell: bool = False) -> None:
    """
    Runs a shell command, and print it before running.

    Arguments:
        cmd: list of a command and its arguments, or as a fallback,
            a string to be passed to a shell that will be split into a list.
        env (optional, default value is os.environ): dictionary containing the
            environment variables
        timeout (optional, int): time in seconds after which the function will
            raise an error if the command hasn't returned

        TODO: remove the temporary `shell` argument once all commands use shell=False
        shell (bool): run the command in a subshell. Defaults to False.

    Both stdout and stderr of the shell in which the command is run are those
    of the parent process.
    """
    print("\nRUN: %s" % cmd)
    t = datetime.datetime.now()
    if not isinstance(cmd, list) and not shell:
        cmd = cmd.split()
    subprocess.run(cmd, shell=shell, stdout=sys.stdout, stderr=sys.stderr,
                   env=env, timeout=timeout, check=True)
    print(datetime.datetime.now() - t)


def matrix_translation(x: float, y: float) -> npt.NDArray[np.float64]:
    t = np.eye(3)
    t[0, 2] = x
    t[1, 2] = y
    return t


def rio_read_as_array_with_nans(im: str) -> npt.NDArray[Any]:
    """
    Read an image replacing gdal nodata value with np.nan

    Args:
        im: path to the input image file

    Returns:
        array: raster as numpy array
    """
    with rasterio.open(im, 'r') as src:
        array: npt.NDArray[Any] = src.read()
        nodata_values = src.nodatavals

    for band, nodata in zip(array, nodata_values):
        if nodata is not None:
            band[band == nodata] = np.nan

    return array.squeeze()


def rasterio_write(path: str,
                   array: npt.ArrayLike,
                   profile: Dict[str, Any] = {},
                   tags: Dict[str, Any] = {}) -> None:
    """
    Write a numpy array in a tiff or png file with rasterio.

    Args:
        path (str): path to the output tiff/png file
        array (numpy array): 2D or 3D array containing the image to write.
        profile (dict): rasterio profile (ie dictionary of metadata)
        tags (dict): dictionary with additional geotiff tags
    """
    # determine the driver based on the file extension
    extension = os.path.splitext(path)[1].lower()
    if extension in ['.tif', '.tiff']:
        driver = 'GTiff'
    elif extension in ['.png']:
        driver = 'png'
    else:
        raise NotImplementedError('format {} not supported'.format(extension))

    # read image size and number of bands
    array = np.atleast_3d(array)
    height, width, nbands = array.shape

    # define image metadata dict
    profile.update(driver=driver, count=nbands, width=width, height=height,
                   dtype=array.dtype)

    # write to file
    with rasterio.Env():
        with rasterio.open(path, 'w', **profile) as dst:
            dst.write(np.transpose(array, (2, 0, 1)))
            dst.update_tags(**tags)


def image_apply_homography(out: str, im: str, H: npt.NDArray[np.float64],
                           w: int, h: int) -> None:
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)).

    This function calls the homography binary, rewritten by Marc Lebrun and
    Carlo de Franchis based on a code of Pascal Monasse refactored by Gabriele
    Facciolo.
    """
    # write the matrix to a string
    hij = " ".join(str(x) for x in H.flatten())

    # apply the homography
    run(["homography", im, "-h", hij, out, "%d" % w, "%d" % h])


def points_apply_homography(H: npt.ArrayLike, pts: npt.ArrayLike) -> npt.NDArray[np.float64]:
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    # if the list of points is not a numpy array, convert it
    pts = np.asarray(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        raise ValueError(
            "The input must be a numpy array"
            "of 2D points, one point per line"
        )
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts: npt.NDArray[np.float64] = np.dot(H, pts.T).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts: npt.ArrayLike) -> Tuple[float, float, float, float]:
    """
    bounding box for the points pts
    """
    pts = np.asarray(pts)
    dim = len(pts[0])  # should be 2
    bb_min = [min([t[i] for t in pts]) for i in range(dim)]
    bb_max = [max([t[i] for t in pts]) for i in range(dim)]
    return bb_min[0], bb_min[1], bb_max[0] - bb_min[0], bb_max[1] - bb_min[1]


def crop_array(img: npt.NDArray[Any], x: int, y: int, w: int, h: int,
               fill_value: float = 0) -> npt.NDArray[Any]:
    """
    Crop an image represented as an array.

    Args:
        img (array): 2D input image
        x, y (ints): coordinate of the top-left corner of the crop
        w, h (ints): width and height of the crop
        fill_value (img.dtype): constant value used for filling the crop
            outside the input image domain

    Returns:
        array with the cropped image
    """
    crop = fill_value * np.ones((h, w), dtype=img.dtype)

    y0 = max(y, 0)
    y1 = min(y + h, img.shape[0])
    x0 = max(x, 0)
    x1 = min(x + w, img.shape[1])

    if y0 < y1 and x0 < x1:  # the requested crop overlaps the image
        crop[y0 - y:y1 - y, x0 - x:x1 - x] = img[y0:y1, x0:x1]

    return crop


def cargarse_basura(inputf: str, outputf: str) -> None:
    se=5
    tmp1 = outputf + '1.tif'
    tmp2 = outputf + '2.tif'
    tmpM = outputf + 'M.tif'
    run('morphoop %s min %d %s' % (inputf, se, tmpM))
    run('morphoop %s max %d %s' % (inputf, se, tmp1))
    run('morphoop %s max %d %s' % (inputf, se, tmpM))
    run('morphoop %s min %d %s' % (inputf, se, tmp2))
    run(["plambda", tmp1, tmp2, inputf, "x y - fabs %d > nan z if" % 5, "-o", tmpM])
    run('remove_small_cc %s %s %d %d' % (tmpM, outputf, 200, 5))
    run('rm -f %s %s %s' % (tmp1, tmp2, tmpM))


_t0 = datetime.datetime.now()
_t1: Optional[datetime.datetime] = None

def print_elapsed_time(since_first_call: bool = False) -> None:
    """
    Print the elapsed time since the last call or since the first call.

    Args:
        since_first_call:
    """
    global _t1
    t2 = datetime.datetime.now()
    if since_first_call:
        print("Total elapsed time:", t2 - _t0)
    else:
        if _t1 is not None:
            print("Elapsed time:", t2 - _t1)
        else:
            print("Elapsed time:", t2 - _t0)
    _t1 = t2
    print()


def reset_elapsed_time() -> None:
    global _t1
    _t1 = datetime.datetime.now()


def linear_stretching_and_quantization_8bit(img: npt.NDArray[Any],
                                            p: float = 1.0) -> npt.NDArray[np.uint8]:
    """
    Simple 8-bit quantization with linear stretching.

    Args:
        img (np.array): image to quantize
        p (float): percentage of the darkest and brightest pixels to saturate,
            from 0 to 100.

    Returns:
        numpy array with the quantized uint8 image
    """
    a, b = np.nanpercentile(img, (p, 100 - p))
    q: npt.NDArray[np.uint8] = np.round(255 * (np.clip(img, a, b) - a) / (b - a)).astype(np.uint8)
    return q
