# Copyright (C) 2015, Carlo de Franchis <carlo.de-franchis@cmla.ens-cachan.fr>
# Copyright (C) 2015, Gabriele Facciolo <facciolo@cmla.ens-cachan.fr>
# Copyright (C) 2015, Enric Meinhardt <enric.meinhardt@cmla.ens-cachan.fr>
# Copyright (C) 2015, Julien Michel <julien.michel@cnes.fr>


from __future__ import print_function
import os
import re
import sys
import errno
import base64
import datetime
import requests
import tempfile
import subprocess
import multiprocessing
import numpy as np
from osgeo import gdal


from s2plib.config import cfg


# add the bin folder to system path
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
bin_dir = os.path.join(parent_dir, 'bin')
os.environ['PATH'] = bin_dir + os.pathsep + os.environ['PATH']

# global variable
# list of intermediary files generated by s2p
garbage = list()


def remove(target):
    try:
        os.remove(target)
    except OSError:
        pass

def garbage_cleanup():
    """
    Removes all the files listed in the global variable 'garbage'.
    """
    if cfg['clean_tmp']:
        while garbage:
            remove(garbage.pop())


def tmpfile(ext=''):
    """
    Creates a temporary file in the cfg['temporary_dir'] directory.

    Args:
        ext: desired file extension. The dot has to be included.

    Returns:
        absolute path to the created file

    The path of the created file is added to the garbage list to allow cleaning
    at the end of the pipeline.
    """
    fd, out = tempfile.mkstemp(suffix=ext, prefix='s2p_',
                               dir=os.path.expandvars(cfg['temporary_dir']))
    os.close(fd)           # http://www.logilab.org/blogentry/17873
    garbage.append(out)
    return out


class RunFailure(Exception):
    pass


def run(cmd, env=os.environ):
    """
    Runs a shell command, and print it before running.

    Arguments:
        cmd: string to be passed to a shell
        env (optional, default value is os.environ): dictionary containing the
            environment variables

    Both stdout and stderr of the shell in which the command is run are those
    of the parent process.
    """
    print("\nRUN: %s" % cmd)
    t = datetime.datetime.now()
    try:
        subprocess.check_call(cmd, shell=True, stdout=sys.stdout,
                              stderr=sys.stderr, env=env)
        print(datetime.datetime.now() - t)

    except subprocess.CalledProcessError as e:
        # raise a custom exception because the CalledProcessError causes the
        # pool to crash
        raise RunFailure({"command": e.cmd, "environment": env, "output":
                          e.output})


def mkdir_p(path):
    """
    Create a directory without complaining if it already exists.
    """
    try:
        os.makedirs(path)
    except OSError as exc: # requires Python > 2.5
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise


def shellquote(s):
    return "'%s'" % s.replace("'", "'\\''")


def matrix_write(filename, m):
    """
    Writes a 3x3 matrix in a txt file using the matlab format.

    Args:
        filename: path of the file where to write the matrix
        m: 3x3 array
    """
    f = open(filename, 'w')
    f.write('[ %.20f  %.20f  %.20f ; ' % (m[0, 0], m[0, 1], m[0, 2]))
    f.write('  %.20f  %.20f  %.20f ; ' % (m[1, 0], m[1, 1], m[1, 2]))
    f.write('  %.20f  %.20f  %.20f ] ' % (m[2, 0], m[2, 1], m[2, 2]))
    f.close()


def matrix_read(filename, size=None):
    """
    Reads a matrix from a txt file assuming the matlab format was used.

    Args:
        filename: path of the file from where to read the matrix
        size: tuple (r, c) telling the number of rows and columns of the matrix

    Returns:
        numpy array
    """
    with open(filename, 'r') as f:
        return matrix_read_from_string(f.read(), size)


def matrix_read_from_string(s, size=None):
    x = s.replace('[', ' ').replace(']', ' ').replace(',', ' ').replace(';', ' ')
    x = map(float, x.split())
    if size:
       return np.array(x).reshape(size[0], size[1])
    else:
       return np.array(x)


def matrix_translation(x, y):
    t = np.eye(3)
    t[0, 2] = x
    t[1, 2] = y
    return t


def image_size_gdal(im):
    """
    Read the width, height and pixel dimension of an image using gdal.

    Args:
        im: path to the input image file

    Returns:
        w, h, pd: a tuple of length 3
    """
    f = gdal.Open(im)
    x = f.RasterXSize
    y = f.RasterYSize
    pd = f.RasterCount
    f = None
    return x, y, pd


def gdal_read_as_array_with_nans(im):
    """
    Read an image replacing gdal NoDataValue with np.nan

    Args:
        im: path to the input image file

    Returns:
        array: raster as numpy array
    """
    raster = gdal.Open(im)
    array = raster.ReadAsArray()

    # replace gdal NoDataValue with np.nan for the np.isfinite counting
    noDataValues = [raster.GetRasterBand(b+1).GetNoDataValue() for b in range(raster.RasterCount)]
    if len(noDataValues) == 1:
        if noDataValues[0] is not None:
            array[array == noDataValues[0]] = np.nan
    else:
        for b in range(raster.RasterCount):
            if noDataValues[b] is not None:
                array_band = array[b, :, :]
                array_band[array_band == noDataValues[b]] = np.nan

    return array


def grep_xml(xml_file, tag):
    """
    Reads the value of an element in an xml file.

    Args:
        xml_file: path to the xml file
        tag: start/end tag delimiting the desired element

    Returns:
        A string containing the element written between <tag> and </tag>
        Only the value of the element associated to the first occurence of the
        tag will be returned.
    """
    try:
        with open(xml_file):
            p1 = subprocess.Popen(['grep', tag, xml_file],
                    stdout=subprocess.PIPE)
            p2 = subprocess.Popen(['cut', '-d', '>', '-f', '2'],
                    stdin=p1.stdout, stdout=subprocess.PIPE)
            p3 = subprocess.Popen(['cut', '-d', '<', '-f', '1'],
                    stdin=p2.stdout, stdout=subprocess.PIPE)
            lines = p3.stdout.read().splitlines()
            if not lines:
                print("grep_xml: no tag %s in file %s" % (tag, xml_file))
                return
            if len(lines) > 1:
                print("grep_xml: WARNING several occurences of %s in file %s" % (tag, xml_file))
            return lines[0]
    except IOError:
        print("grep_xml: the input file %s doesn't exist" % xml_file)
        sys.exit()


def image_fftconvolve(im, mtf):
    """
    returns the fourier convolution: F^{-1} ( F(im)  mtf )
    mtf and im must be the same size
    """
    out = tmpfile('.tif')
    run('fftconvolve %s %s %s' % (mtf, im, out))
    return out


def image_zeropadding_from_image_with_target_size(im, image_with_target_size):
    """
    zooms im by zero padding to the size of the image_with_target_size
    It works with the fft representation of im
    and just adds or remove frequencies from it
    No control of Gibbs artifacts
    """
    out = tmpfile('.tif')
    run('zoom_zeropadding %s %s %s' % (image_with_target_size, im, out))
    return out


def image_apply_pleiades_unsharpening_filter(im):
    """
    Convolve the image by the unsharpening MTF idata_0009_MTF_89x89.tif.

    This filter specifically undoes the sharpening applied to the sensor perfect
    Pleiades images. It has been pre-computed for processing Pleiades sensor
    perfect images resampled with a factor 1.4x. But in theory it should be
    adapted depending on the RESAMPLING_SPACING stored in the RPC xml files.
    """
    mtf = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                       'idata_0009_MTF_89x89.tif')
    mtf_large = image_zeropadding_from_image_with_target_size(mtf, im)
    return image_fftconvolve(im, mtf_large)


def image_safe_zoom_fft(im, f, out=None):
    """
    zooms im by a factor: f in [0,1] for zoom in, f in [1 +inf] for zoom out. It
    works with the fft representation of the symmetrized im thus it controls
    the Gibbs artifacts.
    In case of zoom out it filters the image before truncating the
    spectrum, for zoom in it performs a zero padding.
    Because of the discrete frequency representation the zero padding/
    truncation may yield a final zoom factor that differs from the
    desired one, particularly for small source or target images.
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    sz = image_size_gdal(im)
    # FFT doesn't play nice with infinite values, so we remove them
    run('zoom_2d %s %s %d %d' % (im, out, sz[0]/f, sz[1]/f))
    return out


def image_zoom_gdal(im, f, out=None, w=None, h=None):
    """
    Zooms an image using gdal (nearest neighbor interpolation)

    Args:
        im: path to the input image
        f:  zoom factor. f in [0,1] for zoom in, f in [1 +inf] for zoom out.
        out (optional): path to the ouput file
        w, h (optional): input image dimensions

    Returns:
        path to the output image. In case f=1, the input image is returned
    """
    if f == 1:
        return im

    if out is None:
        out = tmpfile('.tif')

    tmp = tmpfile('.tif')

    if w is None or h is None:
        sz = image_size_gdal(im)
        w = sz[0]
        h = sz[1]

    # First, we need to make sure the dataset has a proper origin/spacing
    run('gdal_translate -a_ullr 0 0 %d %d %s %s' % (w/float(f), -h/float(f),
                                                    im, tmp))

    # do the zoom with gdalwarp
    # -wm gives the max memory in MB. If bigger than 2GB, int overflow
    run(('gdalwarp -r near -co "BIGTIFF=IF_NEEDED" -co "TILED=YES" -wm 2047 -ts'
         ' %d %d %s %s') % (w/float(f), h/float(f), tmp, out))
    return out


def cropImage(inp, out, x, y, w, h, zoom=1):
    """
    Crop a rectangular region and apply a zoom.

    Args:
        inp: path to the input file
        out: path to the output file
        x, y, w, h: upper left corner and size of the rectangular region of
            interest
        zoom (default is 1): zoom factor
    """

    if zoom == 1:
        image_crop_gdal(inp, x, y, w, h, out)
    else:
        # gdal is used for the zoom because it handles BigTIFF files, and
        # before the zoom out the image may be that big
        tmp = image_crop_gdal(inp, x, y, w, h)
        image_zoom_gdal(tmp, zoom, out, w, h)


def image_zoom_out_morpho(im, f):
    """
    Image zoom out by morphological operation (median).

    Args:
        im: path to the input image
        f: zoom out factor. It has to be a positive integer

    Returns:
        path to the output image
    """
    if (f != np.floor(f)):
        print('image_zoom_out_morpho: zoom factor has to be integer')
        sys.exit()

    out = tmpfile('.tif')
    run('downsa e %d %s %s' % (f, im, out))
    return out


def image_apply_homography(out, im, H, w, h):
    """
    Applies an homography to an image.

    Args:
        out: path to the output image file
        im: path to the input image file
        H: numpy array containing the 3x3 homography matrix
        w, h: dimensions (width and height) of the output image

    The output image is defined on the domain [0, w] x [0, h]. Its pixels
    intensities are defined by out(x) = im(H^{-1}(x)).

    This function calls the homography binary, rewritten by Marc Lebrun and
    Carlo de Franchis based on a code of Pascal Monasse refactored by Gabriele
    Facciolo.
    """
    # write the matrix to a string
    hij = " ".join(str(x) for x in H.flatten())

    # apply the homography
    run("homography %s -h \"%s\" %s %d %d" % (im, hij, out, w, h))


def median_filter(im, w, n):
    """
    Applies median filter.

    Args:
        im: path to the input image
        w: window size
        n: number of repetitions

    Returns:
        path to the filtered image
    """
    out = tmpfile('.tif')
    run('cp %s %s' % (im, out))
    for i in range(n):
        run('morphoop %s median %d %s' % (out, w, out))
    return out


def image_qauto(im, out=None):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image
        out (optional, default is None): path to output image

    Returns:
        path of requantized image, saved as png
    """
    if out is None:
        out = tmpfile('.png')
    run('qauto %s %s' % (im, out))
    return out


def image_qauto_gdal(im):
    """
    Uniform requantization between min and max intensity.

    Args:
        im: path to input image

    Returns:
        path of requantized image, saved as png
    """
    out = tmpfile('.png')
    run('gdal_translate -of png -ot Byte -scale %s %s' % (im, out))
    return out


def image_qauto_otb(img_out, img_in, ram=128, gamma=1.5, intensity_cut_high=.1,
                    intensity_cut_low=.1):
    """
    Gamma correction and simplest color balance to 8 bits with otbcli_Convert.

    Args:
        img_out, img_in: paths to output and input images
        ram: allowed memory amount, in MB
        gamma: exponent for the gamma correction applied to the input image
        intensity_cut_high/low: percentage of pixels whose intensity is clipped
            to 255/0.
    """
    gdaltags = ('gdal:co:TILED=YES&'
                'gdal:co:BIGTIFF=IF_SAFER&'
                'gdal:co:PROFILE=BASELINE')
    cmd = ('otbcli_Convert -progress 1 -ram %d'
           ' -type linear'
           ' -type.linear.gamma %f'
           ' -hcp.high %f'
           ' -hcp.low %f'
           ' -in %s'
           ' -out "%s?writegeom=false&%s" uint8') % (ram, gamma,
                                                     intensity_cut_high,
                                                     intensity_cut_low, img_in,
                                                     img_out, gdaltags)
    run(cmd)


def image_qeasy(im, black, white, out=None):
    """
    Uniform requantization between user-specified min and max levels.

    Args:
        im: path to input image
        black: lower threshold. Values lower or equal are mapped to 0
        white: upper threshold. Values greater or equal are mapped to 255
        out (optional, default is None): path to output image

    Returns:
        path of requantized image, saved as png
    """
    if out is None:
        out = tmpfile('.png')
    run('qeasy %d %d %s %s' % (black, white, im, out))
    return out


def pansharpened_to_panchro(im, out=None):
    """
    Converts a RGBI pansharpened image to a graylevel image.

    Args:
        im: path to the input image
        out (optional): path to the output image

    Returns:
        path to the output image
    """
    if out is None:
        out = tmpfile('.tif')
    pcmd = "x[0] x[1] x[2] x[3] + + + 4 /"

    cmd = 'plambda %s \"%s\" -o %s' % (im, pcmd, out)

    run(cmd)
    return out


def rgbi_to_rgb(im, out=None):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, with iio

    Args:
        im: path to the input image
        out (optional): path to the output image

    Returns:
        output rgb image
    """
    if out is None:
        out = tmpfile('.png')
    pcmd = "x[0] x[1] 0.9 * x[3] 0.1 * + x[2] join3"
    cmd = 'plambda %s \"%s\" -o %s' % (im, pcmd, out)
    run(cmd)
    return out


def rgbi_to_rgb_gdal(im):
    """
    Converts a 4-channel RGBI (I for infrared) image to rgb, using gdal

    Args:
        im: path to the input image

    Returns:
        output rgb image
    """
    out = tmpfile('.tif')
    run('gdal_translate -b 1 -b 2 -b 3 %s %s' %(im, out))
    return out


def points_apply_homography(H, pts):
    """
    Applies an homography to a list of 2D points.

    Args:
        H: numpy array containing the 3x3 homography matrix
        pts: numpy array containing the list of 2D points, one per line

    Returns:
        a numpy array containing the list of transformed points, one per line
    """
    # if the list of points is not a numpy array, convert it
    if (type(pts) == list):
        pts = np.array(pts)

    # convert the input points to homogeneous coordinates
    if len(pts[0]) < 2:
        print("""points_apply_homography: ERROR the input must be a numpy array
          of 2D points, one point per line""")
        return
    pts = np.hstack((pts[:, 0:2], pts[:, 0:1]*0+1))

    # apply the transformation
    Hpts = (np.dot(H, pts.T)).T

    # normalize the homogeneous result and trim the extra dimension
    Hpts = Hpts * (1.0 / np.tile( Hpts[:, 2], (3, 1)) ).T
    return Hpts[:, 0:2]


def bounding_box2D(pts):
    """
    bounding box for the points pts
    """
    dim = len(pts[0])  # should be 2
    bb_min = [min([t[i] for t in pts]) for i in range(dim)]
    bb_max = [max([t[i] for t in pts]) for i in range(dim)]
    return bb_min[0], bb_min[1], bb_max[0] - bb_min[0], bb_max[1] - bb_min[1]


def image_crop_gdal(im, x, y, w, h, out=None):
    """
    Crop an image using gdal_translate.

    Args:
        im: path to an image file
        x, y, w, h: four integers definig the rectangular crop in the image.
            (x, y) is the top-left corner, and (w, h) are the dimensions of the
            rectangle.
        out (optional): path to the output crop

    Returns:
        path to cropped tif image
    """
    if int(x) != x or int(y) != y:
        print('WARNING: image_crop_gdal will round the coordinates of your crop')

    if out is None:
        out = tmpfile('.tif')

    try:
        with open(im, 'r'):
            # do the crop with gdal_translate
            run(('gdal_translate -ot Float32 -co TILED=YES -co BIGTIFF=IF_NEEDED '
                 '-srcwin %d %d %d %d %s %s') % (x, y, w, h, shellquote(im),
                                                 shellquote(out)))
    except IOError:
        print("image_crop_gdal: input image %s not found" % shellquote(im))
        sys.exit()

    return out


def run_binary_on_list_of_points(points, binary, option=None, env_var=None):
    """
    Runs a binary that reads its input on stdin.

    Args:
        points: numpy array containing all the input points, one per line
        binary: path to the binary. It is supposed to write one output value on
            stdout for each input point
        option: optional option to pass to the binary
        env_var (optional): environment variable that modifies the behaviour of
            the binary. It is a tuple containing 2 strings, eg ('PATH', '/bin')

    Returns:
        a numpy array containing all the output points, one per line.
    """
    # send the input points to stdin
    pts_file = tmpfile('.txt')
    np.savetxt(pts_file, points, '%.18f')
    p1 = subprocess.Popen(['cat', pts_file], stdout=subprocess.PIPE)

    # run the binary
    env = os.environ.copy()
    if env_var is not None:
        env[env_var[0]] = env_var[1]
    cmd = [binary]
    if option is not None:
        cmd.append(option)
    p2 = subprocess.Popen(cmd, env=env, stdin=p1.stdout,
                          stdout=subprocess.PIPE)

    # recover output values
    out = []
    for i in range(len(points)):
        out.append([float(x) for x in p2.stdout.readline().split()])

    return np.array(out)


def get_rectangle_coordinates(im):
    """
    Get the coordinates of a rectangle defined by the user's clicks.

    Args:
        im: path to an image to be displayed.

    Returns:
        x, y, w, h: coordinates of the rectangle selected by the user. x, y are the
            coordinates of the top-left corner, while (w, h) is the size of the
            rectangle.
    """
    points_file = tmpfile('.txt')
    run('python s2plib/viewGL.py %s > %s' % (shellquote(im), points_file))
    x1, y1, x2, y2 = map(int, open(points_file).read().split())
    # viewGL.py returns the coordinates of two corners defining the rectangle.
    # We can's make any assumption on the ordering of these coordinates.

    x = min(x1, x2)
    w = max(x1, x2) - x
    y = min(y1, y2)
    h = max(y1, y2) - y
    return x, y, w, h


def get_roi_coordinates(img, preview):
    """
    Coordinates of a rectangle in a large image from user clicks on a preview.

    Args:
        img: path to the large image file
        preview: path to the preview image file

    Returns:
        x, y, w, h: coordinates of the rectangle selected by the user, in the
            large image frame. x, y are the coordinates of the top-left corner,
            while (w, h) is the size of the rectangle.

    A preview image is displayed, on which the user selects a rectangle.
    """
    # read preview/full images dimensions
    nc, nr = image_size_gdal(img)[:2]
    nc_preview, nr_preview = image_size_gdal(preview)[:2]

    # get the rectangle coordinates
    x, y, w, h = get_rectangle_coordinates(preview)

    # rescale according to preview/full ratio
    x = int(x*nc/nc_preview)
    y = int(y*nr/nr_preview)
    w = int(w*nc/nc_preview)
    h = int(h*nr/nr_preview)
    return x, y, w, h


def is_exe(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)


def which(program):
    """
    Test if a program exists, and returns its path.

    Args:
        program: name of the binary, or its full path. For example, "ls", or
            "/bin/ls".

    Returns:
        full path to the binary if it exists

    This function was copied from:
    http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
    """
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file


def download(to_file, from_url):
    """
    Download a file from the internet.

    Args:
        to_file: path where to store the downloaded file
        from_url: url of the file to download
    """
    r = requests.get(from_url, stream=True)
    file_size = int(r.headers['content-length'])
    print("Downloading: %s Bytes: %s" % (to_file, file_size))

    downloaded = 0
    with open(to_file, 'wb') as f:
        for chunk in r.iter_content(chunk_size=8192):
            if chunk:  # filter out keep-alive new chunks
                f.write(chunk)
                downloaded += len(chunk)
                status = r"%10d  [%3.2f%%]" % (downloaded, downloaded * 100. / file_size)
                status = status + chr(8)*(len(status)+1)
                print(status, end=" ")


def cargarse_basura(inputf, outputf):
    se=5
    tmp1 = outputf + '1.tif'
    tmp2 = outputf + '2.tif'
    tmpM = outputf + 'M.tif'
    run('morphoop %s min %d %s' % (inputf, se, tmpM))
    run('morphoop %s max %d %s' % (inputf, se, tmp1))
    run('morphoop %s max %d %s' % (inputf, se, tmpM))
    run('morphoop %s min %d %s' % (inputf, se, tmp2))
    run('plambda %s %s %s "x y - fabs %d > nan z if" -o %s' % (tmp1, tmp2, inputf, 5, tmpM))
    run('remove_small_cc %s %s %d %d' % (tmpM, outputf, 200, 5))
    run('rm -f %s %s %s' % (tmp1, tmp2, tmpM))


def print_elapsed_time(since_first_call=False):
    """
    Print the elapsed time since the last call or since the first call.

    Args:
        since_first_call:
    """
    t2 = datetime.datetime.now()
    if since_first_call:
        print("Total elapsed time:", t2 - print_elapsed_time.t0)
    else:
        try:
            print("Elapsed time:", t2 - print_elapsed_time.t1)
        except AttributeError:
            print("Elapsed time:", t2 - print_elapsed_time.t0)
    print_elapsed_time.t1 = t2
    print()
